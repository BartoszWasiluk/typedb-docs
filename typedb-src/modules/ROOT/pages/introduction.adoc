= Introduction
:keywords: typedb, database, documentation, introduction, overview
:longTailKeywords: typedb introduction, typedb overview, learn typedb, learn typeql, typedb schema, typedb data model
:pageTitle: TypeDB introduction
:summary: A bird's-eye view of TypeDB.

== Summary

TypeDB is a transactional (https://en.wikipedia.org/wiki/Online_transaction_processing[OLTP,window=_blank])
strongly typed DBMS with xref:development/connect.adoc#_acid_guarantees[ACID] guarantees that is unique in many ways:

* uses its own declarative query language: xref:typeql:ROOT:overview.adoc[TypeQL,window=_blank]
* has its own special xref:fundamentals/types.adoc[static type system] that lets us create our own types by
  subtyping and xref:typedb::fundamentals/types.adoc#_inheritance[inheritance], like OOP languages
// #todo add a better link for strong typing
* uses an xref:fundamentals/types.adoc#_type[Entity-Relationship model], extended with
xref:fundamentals/types.adoc#_attribute_types[Attributes] as first-class citizens
// #todo add link to the types article?
* can use rule-based embedded logic to xref:fundamentals/inference.adoc[infer] new data from existing data,
  that matches specified patterns

////
Comparison of TypeDB with most common types of databases:

* xref:../../12-comparisons/00-sql-and-typeql.adoc[SQL]
* xref:../../12-comparisons/01-semantic-web-and-typedb.adoc[Semantic web]
* xref:../../12-comparisons/02-graph-databases-and-typedb.adoc[Graph]
////

//== Thinking in TypeQL and TypeDB

The core of any TypeDB database is the xref:development/schema.adoc#_schema[schema], which is a conceptual (logical)
data representation rather than a physical one.

Using TypeQL, we define a schema to model business domain true to nature.

All user-defined types are either subtypes of other user-defined types or directly subtype one of the following
built-in types:

* Entities -- self-sufficient objects
* Relations -- n-ary relationships
* Attributes -- a property with a value which can be numeric, text string, boolean or date&time

////
[NOTE]
====
_Entity_, _Relation_ and _Attribute_ correspond to the components of an Entity-Relation-Attribute model, an
extension of the well-known https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model[ER model,window=_blank],
in which attributes are also treated as first-class citizens.
====
////

Accurate type hierarchy can add context and constraints to data using strong typing with inheritance.

Finally, rules add logical deduction to a schema. When Get queries are run with the inference transaction
option enabled, TypeDB deduces new attribute ownerships and relations based on these rules.

// ** Context helps us to correctly model, classify and query our data the most logical way.
// ** Constraints are used for query validation and limiting the scope of queries.

== TypeDB classification

TypeDB is a new kind of database management system, combining strongly-typed type system, fully declarative
query language, and inference.

We prefer to classify TypeDB as a strongly-typed DBMS.

Some examples of what TypeDB is *not*:

* Not an SQL database, but it uses an enhanced Entity-Relationship model, further extended by attributes as first-class
  citizens.
* Not a graph database, but it utilizes the power of https://en.wikipedia.org/wiki/Hypergraph[hypergraphs,window=_blank]
  without developers having to understand the implementation details.
* Not an object-oriented database, but it uses types with subtyping and inheritance to model data.
// #todo Elaborate why we can't be classified as one of these here or provide links to blog post about it

== TypeDB description

// very high level short description with hypothesis at the end
TypeDB is a strongly-typed database which encourages us to model data naturally, and to create a logical and accurate
reflection of our business domain. Further, its fully declarative query language, TypeQL, combined with its powerful
reasoning engine, makes it easy to find data by simply describing what you’re looking for.

// schema modelling and top features
TypeDB allows us to model data directly on logical level with object-oriented principles. Composed of entity,
relationship, and attribute types, as well as type hierarchies, roles, and rules, TypeDB allows you to think
higher-level as opposed to join-tables, columns, documents, vertices, edges, and properties.

* Inheritance and type inference allow us to define a hierarchy of subtypes to reduce complexity and add context to
  the data.
* Type constraints of relation roles and attribute ownerships further enhance our schema, provide not only type
  validation to prevent errors, but also a meaning for a data context and an optimization for query execution.
* Apply object-oriented principles such as abstraction, inheritance and polymorphism in your data model, just like
  you do in your application model.
* Create unary or n-ary relations (i.e., hyper-relations) to communicate the full context of relationships.
* Finally, rule inference provides not only query simplification (like views in SQL), but also an embedded logic
  for our schema.

These abstractions provide a higher-level framework to build an intuitive and understandable data model in the form of
a database schema.

// queries and patterns
TypeQL brings together xref:typedb::fundamentals/patterns.adoc#_patterns_overview[pattern] matching and composability,
so writing queries is as easy as describing the data we’re looking for. We never have to tell the database what to do.
Its intuitive syntax and use of variables grants a near limitless degree of expressiveness to TypeQL.
By simply adding or removing statements to a query pattern, we can narrow or expand the scope of its results.
We don't have to think about query optimization, limitations of data storage implementation, etc.
Queries written in TypeQL are easily readable, sound natural and familiar to subject-matter experts.

// inference
Finally, we can use the reasoning engine to infer new data based on the patterns found in the database. To do
that, we define rules in the database schema. Rules can dramatically shorten complex queries (e.g., transitivity of
relations), perform xref:development/infer.adoc#_explain_query[explainable] knowledge discovery, and implement business
logic at the database level.

// Conclusion
By combining TypeQL and TypeDB, we can close the gap between the language of our domain and the database.
TypeDB is optimized for easier data modeling and query design.
Concentrated on your applications logic and leave the data storage implementation details for TypeDB!

//TypeDB is optimized not for reading or writing vast amounts of data but for easier data modeling and query design.

////
// comparison with other databases
// #todo rewrite with more content, than just relations. Maybe with links to blog posts
In other databases, we implement relations with a join table (SQL) or an edge between two vertices
(graph databases). TypeDB relations generalize both: they flexibly relate one, two, or any number of roles. And each
role can be played by any types defined as role-players for this particular role in the schema.

////
////
In other databases, relations may be implemented with a join table
(xref:../../12-comparisons/00-sql-and-typeql.adoc[SQL]), or an edge between two vertices
(xref:../../12-comparisons/02-graph-databases-and-typedb.adoc[graph] databases). TypeDB relations generalize both: they
flexibly relate one, two, or any number of data instances at the same time.

////
////

This expanded idea of a relation is more powerful than either SQL or graph relations. However, we can further
improve this idea: if we allow relations not just to specify which instances relate to each other but also _how_
they relate by adding context. This has been implemented in the form of a role.

Any relation type specifies one or many roles connected by this relation. Any type in a schema can play roles
that were explicitly defined in the type definition. Roles have labels that provide the context and type
constraints for roles to enforce this context.
////

== Learn more

1. Install TypeDB with our xref:installation.adoc[Installation guide].

2. Make your first steps by connecting to TypeDB server with TypeDB Studio using the
   xref:quickstart.adoc[Quickstart guide].
+
It goes through the step-by-step process of creating a new database, applying schema, loading sample data
   and querying. The resulting environment is suitable for executing most examples in our documentation.
   On top of that it familiarizes users with TypeDB Studio, an IDE specifically designed for TypeDB
   database management and development.

3. Fundamentals -- essential knowledge of how TypeDB works:

    * xref:fundamentals/types.adoc[]
    * xref:fundamentals/queries.adoc[]
    * xref:fundamentals/patterns.adoc[]
    * xref:fundamentals/inference.adoc[]

4. xref:development/connect.adoc[Connect] page: Connect to TypeDB using databases, sessions, transactions, and ACID
   guarantees.

5. xref:development/schema.adoc#_schema[Define schema] page: Find out how to define, undefine, and modify types and rules
   in a TypeDB database.

6. xref:typedb::development/write.adoc[Writing data] and xref:typedb::development/read.adoc[Reading data] pages: How to perform Insert,
   Delete, Update, and Get queries.

7. xref:development/response.adoc[Response interpretation] page: How to use responses from TypeDB.
