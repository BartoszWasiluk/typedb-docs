= Advanced patterns & Queries
:Summary: Targeting instances of data or schema types that match a TypeQL pattern.
:keywords: typeql, query, match, pattern, statement, variable
:longTailKeywords: typeql match, query pattern, match clause, typeql variables, answers
:pageTitle: Advanced patterns & Queries
//:toclevels: 4

// #todo Change the link to TypeQL -

TypeDB queries are written in TypeQL and use patterns to manipulate the schema and data of a database.

In TypeQL, a `match`, `get`, `insert`, or `delete` keyword followed by a pattern (consisting of one or more
statements) is a clause.

These clauses can be combined to create four different types of queries:

* Reading schema and data
 ** xref:typeql::data/get.adoc[Get] (match-get) query -- to retrieve data instances or schema types.
* Writing data
 ** xref:typeql::data/insert.adoc[Insert] (match-insert) query -- to insert data.
 ** xref:typeql::data/delete.adoc[Delete] (match-delete) query -- to delete data.
 ** xref:typeql::data/update.adoc[Update] (match-delete-insert) query -- to delete and then insert data.

A `match` clause is optional for insert queries, but required for all others.

[NOTE]
====
While the `match` clause can be used to read types from a schema, to write types to a schema use the
xref:schema.adoc#_define[define] and
xref:schema.adoc#_undefine_a_type[undefine] clauses instead of insert/delete.
====

[IMPORTANT]
====
If a `match` clause is **not** followed by a `get`, `insert`, or `delete` clause, TypeDB assumes it is a
xref:read.adoc#_get_query[get query] and adds an implicit `get` clause to return all variables defined in the
`match` clause.
====

[#_patterns_overview]
== Patterns overview

TypeQL is *declarative* language. When writing a TypeQL pattern for query, we describe a set of
requirements or constraints for the concepts (types or instances) we would like to match (to perform
xref:read.adoc#_get_query[get]/xref:write.adoc#_insert_query[insert]/xref:write.adoc#_delete_query[delete]/xref:write.adoc#_update[update] query).
Rather than writing an algorithm of how the data should be retrieved,
we declare requirements and the TypeDB query processor will take care of finding an optimal way to retrieve it.

[NOTE]
====
TypeQL is both a https://en.wikipedia.org/wiki/Data_definition_language[Data Definition Language,window=_blank] and
https://en.wikipedia.org/wiki/Data_manipulation_language[Data Manipulation Language,window=_blank].
====

In general, a pattern can be thought of as a system of equations, where every equation is a single statement. TypeDB
will solve the system to find all solutions. Every solution includes a concept (type or instance) for every variable.

TypeQL statements constitute the smallest building blocks of queries. Please find below a closer look at the typical
statement structure.

[#_statement-structure]
image::statement-structure.png[Statement structure]

* A TypeQL variable is prefixed with a dollar sign `$`. Most statements start with a variable (`V`) providing a
reference to a concept or multiple concepts (up to one per every solution found). For more information on variables
see the <<_variables,Variables>> section.
* The variable is followed by a comma-separated list of constraints (`p1`, `p2`, `p3`) describing the concepts the
variable refers to.
* We mark the end of the statement with a semicolon (`;`).

[#_solutions]
It's important to understand that the *result* of a `match` clause with any pattern is a *set of solutions found*.
The length of the set is equal to the number of solutions found, hence it can be:

* Zero -- No solutions found (nothing matched the pattern). Empty set returned.
* One -- Exactly one solution found and returned in a set.
* Many -- Multiple solutions found, including all possible permutations. All of them returned in a set.

For example, in the <<_statement-structure,statement>> illustrated above TypeDB will find all solutions that include a
`person` entity that has a `full-name` attribute of `Masako Holley` and has any email.

What if there is no `person` entity with this particular name in a database? Then a set of zero solutions (answers)
will be returned, regardless of the emails.

What if there is one `person` with the `full-name` attribute like that, but it has two `email` attributes?
Then TypeDB will find two solutions/answers. And every answer will include that one `person` entity and one of the
emails.

[IMPORTANT]
====
A `match` clause returns all possible <<_solutions, solutions>> (combinations of variables values that make pattern a
`true` statement), including all possible permutations. It's very important to understand how `match` clause matches
patterns. Especially if it's used as a part of an insert or delete query, because the `insert` or `delete` clause in
these will be executed once for every matched result from `match` clause used.

For example, we match for all instances of *two* different types without any additional constraints.
Let's say one of the types has **2** instances and the other one has **10** instances. Then `match` clause returns
all matched combinations including all permutations: **20 matched results** in total.
====

[#_variables]
== Variables

There are two types of variables:

* Concept variable -- used *by default* in most queries. Reference a concept (either an instance of data or a type).
* Value variable -- used only in computation, like xref:match.adoc#_arithmetic_operations[arithmetic operations]
  and other xref:match.adoc#_built_in_functions[built-in functions], requiring direct operation on values.

A concept variable starts with dollar sign `$` followed by variable label (for example, `$x`) and reference exactly
one concept (type or data) per every answer (solution) found for a pattern. See <<_example>> below.

A value variable starts with question mark `?` followed by variable label (for example, `?x`) and reference exactly
one value per every answer (solution) found for a pattern. See <<_value_variables>> below.

[#_example]
=== Example

There is great flexibility in designing our statements. Since all statements in a pattern are equal we can use
variables in any order to add constraints to a pattern.

For example, as shown below, we could write our single statement with three constraints:

[,typeql]
----
$p isa person, has full-name 'Masako Holley', has email $email;
----

However, we can also separate this statement into three different statements in a similar pattern to achieve the same
result:

[,typeql]
----
$p isa person;
$p has full-name 'Masako Holley';
$p has email $email;
----

[NOTE]
====
To create a viable query from the pattern above, we need to add the keyword `match` at the beginning. After that
it is ready to be sent via any TypeDB Client to a TypeDB server with a database with an appropriate schema.

[,typeql]
----
match
  $p isa person;
  $p has full-name 'Masako Holley';
  $p has email $email;
----
====

[IMPORTANT]
====
To run these and other examples from our documentation, make sure to complete the
xref:typedb:ROOT:quickstart.adoc[Quickstart guide] to set up the database with the relevant schema and dataset. Do not use
the database created for the xref:schema.adoc[schema] page, as it was only for demonstration of schema
definition.
====

[NOTE]
====
All indentation and line breaking is optional in TypeQL. We can even try using a single line or a completely random
indentation for all our queries, but that will make it harder for us to read them.
====

[#_value_variables]
=== Value variables

Additionally, to the default concept xref:read.adoc#_variables[variables], that address concepts inside a
TypeDB database, there is a special type of variables, used only for xref:match.adoc#_computation[computation].

They are called Value variables.

Instead of dollar sign (e.g., `$p`) value variables use question mark (e.g., `?x`) preceding the variable label.

Instead of concepts, value variables represent exact value in a pattern.
To set value variable with some value we can use `=` sign: with value variable on the left from it and on the right
side -- we shall have an <<_expression,expression>>. Value variables are never materialised permanently, and only used
within the scope of a particular query or rule. To persist the value of a value variable we can use an attribute type
with a matching value type. Value variables can be one of the following value types (the same as value types for
attributes):

* `long`,
* `double`,
* `boolean`,
* `string`,
* `datetime`.

[#_expression]
*Expression* describes the computation of the value for value variable. It contains any combination of the following
elements:

* constant, set in a query (e.g., `?x = 4`),
* value of a concept variable (it should be an attribute to have a value) or value variable, bound in the query,
* <<_arithmetic_operations,arithmetic operation>>,
* other <<_built_in_functions,built-in function>>.

For example:

[,typeql]
----
match
  $s isa size-kb;
  ?x = round($s/2) + 1;
----

The query above will find all instances of data for the `size-kb` attribute type for a concept variable `$s`.
For a value variable `?x` we divide value of the instance of attribute in `$s` by a constant value `2`, rounding it,
and add 1 to the result. Hence, every result for this query consists of `$s` and `?x`:

* `$s` equals to a value of an attribute of `size-kb` type,
* `?x` equals the result of computation we described in the query, that depends on value of the attribute.

[#_pattern_syntax]
== Pattern syntax

=== Schema

The statements below can be used to find types and roles defined in a database's schema.

[cols="^1,2"]
|===
| *What we are looking for in a schema* ^.^| *Pattern syntax*

| type
| `$<var_label> type <type>;`

| subtype
| `$<var_label> sub[!] <type>;`

| role type in a relation
| `<relation> relates $<var_label>;`

| players type in a relation
| `$<var_label> plays <relation>:<role>;`

| owner of attribute type
| `$<var_label> owns <attr-type>;`

| attribute subtype
| `$<var> sub[!] <attribute-type> [, value <value-type>];`
|===
//#todo Add column Examples!

=== Data

The statements below can be used to find data in a database.

[cols="^1,2"]
|===
| *What we are looking for in data* ^.^| *Pattern syntax*

| instance
| `+$<var_label> isa[!] <type> [, <has-attribute statement>...];+`

| attribute
| `+$<var_label> [isa[!] <attr-type>] (contains "<text>" &#124; like "<regex>" &#124; <value>) [, <has-attribute statement>...];+`

| relation
| `+[$<var_label>] ([<role>:] $<var_label> [, [<role>:] $<var_label>]...) isa <relation-type> [, <has-attribute statement>...];+`

| has-attribute statement
| `+has <attr-type> ($<var_label> &#124; [<comparison-operator>] <value> );+`

| comparison
| `$<var_label> [<comparison-operator>] <value>;`

| equal
| `$<var_label> is $<var_label>;`
|===

=== Comparison operators

The following operators are supported for comparing attribute values: `==`, `!=`, `>`, `>=`, `<`, and `+<=+`.

[WARNING]
====
In TypeDB version 2.18.0 the usage of `=` sign as a comparison operator was *deprecated* as it is being used now
to assign values to value variables.

We recommend using `==` for comparison instead.

The old syntax, for example:

[,typeql]
----
$p = $u;
----

will be supported for backwards compatibility for a limited time (if it's used with concept variable on the left from
the `=` sign).

It will be removed from the TypeQL syntax in later versions of TypeDB.
====

[#_computation]
=== Computation

[#_arithmetic_operations]
==== Arithmetic operations

The following keywords can be used for arithmetic operations between value variables, values of attributes, that are
stored in concept variables, or constants:

1. `()` -- parentheses. See <<#_using_parentheses,example>>.
2. `^` -- exponentiation (power). See <<#_using_exponentiation,example>>.
3. `*` -- multiplication. See <<#_using_multiplication,example>>.
4. `/` -- division. See <<#_using_division,example>>.
5. `%` -- https://en.wikipedia.org/wiki/Modulo[modulo,window=_blank]. Returns the remainder of a division.
   See <<#_using_modulo,example>>.
6. `+` -- addition. See <<#_using_addition,example>>.
7. `-` -- subtraction. See <<#_using_subtraction,example>>.

[IMPORTANT]
====
The above list is sorted by the order in which those operations applied.
====

For example:

[,typeql]
----
$f isa file, has size-kb $s;
?mb = $s/1024;
?mb > 1;
----

In the example above we designed a pattern to find instances of data for `file` type owning `size-kb` attribute
with value, that after dividing it by 1024 (to get megabytes out of kilobytes), is bigger than 1.

[#_built_in_functions]
==== Built-in functions

Built-in functions usually invoked with adjacent parentheses that contain arguments to apply function on. Those
arguments, separated by a comma as a separator. The following built-in functions are available in TypeDB:

* `min` -- found minimum of the arguments. See <<#_using_minimum_function,example>>.
* `max` -- found maximum of the arguments. See <<#_using_maximum_function,example>>.
* `floor` -- floor function (rounding down). See <<#_using_floor_function,example>>.
* `ceil` -- ceiling function (rounding up). See <<#_using_ceiling_function,example>>.
* `round` -- default rounding function. See <<#_using_rounding_function,example>>.
* `abs` -- modulus (or absolute value) function. See <<#_using_absolute_value_function,example>>.

=== Combining statements

image::pattern-structure.png[Combining statements]

By arranging statements together, we can express more complex pattern scenarios and their corresponding data.

* *Statement*: Simplest possible arrangement -- a single basic building block as <<_patterns_overview,explained above>>.
* *Conjunction* (logical `AND`): A set of statements, where to satisfy a match, all statements must be true.
We use conjunctions by default just by separating the partaking statements with semicolons `;`.
* *Disjunction* (logical `OR`): A set of statements, where to satisfy a match, at least one statement must be matched.
We form disjunctions by enclosing the partaking statements within curly braces `{}` and joining them together with the
keyword `or`.
* *Negation* (logical negation): A statement that explicitly defines conditions that must *not* to be met. We form
negations by defining the conditions *not* to be met in curly brackets of a `not {};` block.

See the <<_complex_example,complex example>> below.

== Match clause examples

=== Schema queries

A `match` clause can be used to find types or roles in a database schema.

==== Type matching

===== All types

Use a `subtype` pattern with the built-in type `thing` to find all types defined in a schema. For more information see
the xref:schema.adoc#_thing_type[Thing type] section.

[,typeql]
----
match $t sub thing;
----

[WARNING]
====
The `thing` built-in type will be deprecated in one of the upcoming versions and deleted in TypeDB version 3.0.
Consider using `entity`, `attribute`, or `relation` built-in types instead. To produce the same result as the above
example, use the following query:

[,typeql]
----
match $s sub $t; { $t type entity; } or { $t type relation; } or { $t type attribute; };
----
====

===== Specific type or nested subtype

Use a `subtype` pattern to find a specific type and all of its subtypes.

[,typeql]
----
match $o sub object;
----

The above pattern finds the `object` type and all of its nested subtypes: direct (i.e., `resource` and `resource-collection`)
and indirect (i.e., `file`, `interface`, `directory`, and `application`).

===== Direct subtypes

Use a `subtype` pattern with an exclamation mark (`!`) to find the direct subtypes of a specific type.

[,typeql]
----
match $o sub! object;
----

The above query finds all direct subtypes of the `object` type (i.e., `resource` and `resource-collection`).

===== Attribute types (by value type)

Use an `attribute subtype` pattern to find all attribute types with a specific value type.

[,typeql]
----
match $a sub attribute, value boolean;
----

The above query finds all attribute types that have a `boolean` value type.

===== Specific type

Use a `type` pattern to find a specific type, excluding any nested subtypes (direct or indirect).

[,typeql]
----
match $o type object;
----

The above query returns the `object` type, and none of its nested subtypes (direct or indirect).

===== Players of a specific role

Use a "players type in a relation" pattern to find all types that play a specific role in a specific relation type.

[,typeql]
----
match $p plays permission:subject;
----

The above query finds all types that can play the `subject` role in the `permission` relation type.

===== Owners of a specific attribute type

Use an `owners of attribute type` pattern to find all types that own a specific attribute type.

[,typeql]
----
match $o owns full-name;
----

The above query finds all types that own the `full-name` attribute.

==== Role matching

Use the `role types in a relation` pattern to find all roles in a specific relation.

[,typeql]
----
match permission relates $r;
----

The above query finds all the roles defined in the `permission` relation type (`permission:access` and
`permission:subject`).

=== Data queries

A `match` clause can be used to find data in a database.

==== All data

Use an `instance` pattern with type `thing` to find all entities, relations, and attributes (instances of data).
For more information see the xref:schema.adoc#_thing_type[Thing type] section.

[,typeql]
----
match $t isa thing;
----

[WARNING]
====
The `thing` built-in type will be deprecated in one of the upcoming versions and deleted in TypeDB version 3.0.
Consider using `entity`, `attribute`, or `relation` built-in types instead. To produce the same result as the above
example, use the following query:

[,typeql]
----
match $t isa $a; {$a type entity;} or {$a type relation;} or {$a type attribute;};
----
====

==== Entity matching

===== Specific types or nested subtypes instances

Use an `instance` pattern to find all entities of a specific entity type (and of all its subtypes).

[,typeql]
----
match $p isa person;
----

The above query returns all entities of the `person` entity and any of its nested subtypes.

[IMPORTANT]
====
The `isa` keyword will return all direct and indirect (of all subtypes of the given type) instances.
To limit results to only direct instances of the given type use `isa!` instead. See the
<<_specific_types_instances,example>> below.
====

[#_specific_types_instances]
===== Specific types instances

Use an `instance` pattern with an exclamation mark (`!`) to find all entities of a specific type only
(and none of its nested subtypes).

[,typeql]
----
match $u isa! user;
----

The above query finds all `user` entities. It excludes any entities whose type is a nested subtype of `user`,
so `person` entities would not be included.

===== Owners of a specific attribute type

Use an `instance` pattern with `has-attribute statement` pattern to find all entities that own an attribute of a
specific type.

[,typeql]
----
match $p isa person, has full-name $n;
----

The above query finds all `person` entities that own a `full-name` attribute.

===== Owners of specific attribute types (multiple)

Use an `instance` pattern with multiple `has-attribute statements` to find all entities that own a specific set of
attributes, each of a specific type.

[,typeql]
----
match $p isa person, has full-name $n, has email $email, has credential $cr;
----

The above query finds all `person` entities that have `full-name`, `email`, and `credential` attributes.

===== Owners of a specific attribute (by type and value)

Use an `instance` pattern with `has-attribute statement` pattern to find all entities that own a specific attribute
with a specific value.

[,typeql]
----
match $p isa person, has full-name “Kevin Morrison”;
----

The above query finds all `person` entities that have a `full-name` attribute with a value of "`Kevin Morrison`".

===== Owners of a specific attribute (by type and value range)

Use an `instance` pattern with a `has-attribute statement` containing a comparison operator to find all entities that
have a specific attribute whose value is within a specific range.

[,typeql]
----
match $f isa file, has size-kb < 100;
----

However, if the attribute value itself is required in the query response, combine a `has-attribute statement`
(with no comparison operation) with a separate `comparison` pattern.

[,typeql]
----
match
  $f isa file, has size-kb $s;
  $s < 100;
----

==== Relation matching

The pattern used to find relations is different from the one used to find entities because relations have role players
(entities, other relations, and/or attributes).

===== Role players

Use a `relation pattern` with a matched role player to find all relations of a specific type that relate a
specified instance.

[,typeql]
----
match
  $p isa person, has full-name "Kevin Morrison";
  $pe (subject: $p) isa permission;
----

The above query finds all `person` entities (`$p`) owning a `full-name` attribute with a value of `Kevin Morrison`
and then it finds all `permission` relations (`$pe`) in which those entities `$p` play the `subject` role.

===== Owners of a specific attribute (with value)

Use a `relation pattern` with a `has-attribute statement` to find all relations of a specific type and which have a
specific attribute with a specific value.

[,typeql]
----
match $pe (subject: $p, access: $ac) isa permission, has validity true;
----

The above query finds all `permission` relations which have a `validity` attribute whose value is `true`.

===== With no relation variable

The relation variable can be omitted when only the role players are needed.

[,typeql]
----
match (subject: $p, access: $ac) isa permission;
----

===== With no role names

The names of a relation's roles can be omitted.

[,typeql]
----
match $pe ($p, $ac) isa permission;
----

This will match any valid combination of roles.

==== Attribute matching

There are multiple ways to find attributes depending on the use case.

===== Value

Use a variable and an attribute value to find all attributes with a specific value.

[,typeql]
----
match $x "Masako Holley";
----

The above query finds all attributes with a value of "`Masako Holley`", regardless of their type.

===== Type and value

Combine an `attribute` pattern with a `comparison` pattern to find all attributes of a specific type and with a
specific value.

[,typeql]
----
match
  $n isa full-name;
  $n "Masako Holley";
----

Or use this compact form:

[,typeql]
----
match $n "Masako Holley" isa full-name;
----

The above queries finds all `full-name` attributes with a value of `Masako Holley`.

===== Value containing

Use an `attribute` pattern with `contains` keyword to find all attributes whose value contains specific string.

[,typeql]
----
match $name contains "Masako";
----

The above query finds all attributes whose value contains the text `Masako`, regardless of their type.

===== Value matching regex

Use an `attribute` pattern with `like` keyword and a regular expression to find all attributes whose value matches
the specified regular expression pattern.

[,typeql]
----
match $x like "(Masako Holley|Kevin Morrison)";
----

The above query finds all attributes whose value is `Masako Holley` or `Kevin Morrison`, regardless of their type.

==== Equality

Use an `equal` pattern to check if two variables represent the same instance (or instances).
That not only means equality by type and value but literary being the same instance(s) of data in a database.
It is often helpful in negation.

[,typeql]
----
match
  $x isa person;
  $y isa person;
  not { $x is $y; };
----

The above query returns pairs of users that are not the same user.

==== Computation

[#_using_parentheses]
===== Using parentheses

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = ($s + 5) * 2;
----

In the above example parentheses are used to change order of operations: addition inside the parentheses will happen
before multiplication.

[#_using_exponentiation]
===== Using exponentiation

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s ^ 2;
----

In the above example we set value variable `?x` to be equal to the result of exponentiation:
value of `$s` raised to the power of 2.

[#_using_multiplication]
===== Using multiplication

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s * 3;
----

In the above example we multiply the value of `$s` by 3 and set the value variable `?x` to be equal to the result.

[#_using_division]
===== Using division

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s / 3;
----

In the above example we divide the value of `$s` by 3 and set the value variable `?x` to be equal to the result.

[#_using_modulo]
===== Using modulo

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s % 3;
----

In the above example we set the value variable `?x` to be equal to the result of modulo operation between `$s` and 3.
Or `$s` mod 3.

[#_using_addition]
===== Using addition

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s + 1250;
----

In the above example we add the value of `$s` to 1250 and set the value variable `?x` to be equal to the result.

[#_using_subtraction]
===== Using subtraction

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s - 300;
----

In the above example we subtract 300 from the value of `$s` and set the value variable `?x` to be equal to the result.

[#_using_minimum_function]
===== Using minimum function

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s - 300;
  ?a = min($s, ?x);
----

In the above example we set the value variable `?x` to be equal to either `$s` or `?x`, whichever is the minimum.

[#_using_maximum_function]
===== Using maximum function

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = $s - 300;
  ?a = max($s, ?x);
----

In the above example we set the value variable `?x` to be equal to either `$s` or `?x`, whichever is the maximum.

[#_using_floor_function]
===== Using floor function

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = floor($s / 3);
----

In the above example we set the value variable `?x` to be equal to the result of floor function (the greatest integer
less than or equal to the argument).

[#_using_ceiling_function]
===== Using ceiling function

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = ceil($s / 3);
----

In the above example we set the value variable `?x` to be equal to the result of ceiling function (the least integer
greater than or equal to the argument).

[#_using_rounding_function]
===== Using rounding function

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = round($s / 3);
----

In the above example we set the value variable `?x` to be equal to the result of rounding function (rounding to the
nearest integer, half up).

[#_using_absolute_value_function]
===== Using absolute value function

[,typeql]
----
match
  $f isa file, has size-kb $s;
  ?x = abs($s - 1000);
----

In the above example we set the value variable `?x` to be equal to the result of absolute value function (discarding
the sign).

==== Conjunctions

By default, a collection of statements in a `match` clause, divided by semicolons, constructs a conjunction of
statements.

[,typeql]
----
match
  $p isa person, has full-name "Kevin Morrison";
  $o isa object, has path $o-path;
  $ac(object: $o) isa access;
  $pe(subject: $p, access: $ac) isa permission;
----

The above example uses conjunction to ensure all statements are matched:

. Find all `person` entities (`$p`) that have a `full-name` attribute whose value is `Kevin Morrison`.
. Find all `object` entities (`$o`) that have a `path attribute` (`$o-path`).
. Find all `access` relations (`$ac`) where `$o` plays the `object` role.
. Find all `permission` relations (`$pe`) where `$p` plays the `subject` role, `$ac` the `access` role.

The `object` entities are limited to those which play the `object` role in `access` relations, which are themselves
limited to those which play the `access` role in `permission` relations. The `permission` relations are limited to
those in which matching `person` entities play the `subject` role.

==== Disjunctions

To include statements in the form of a disjunction, we need to wrap each statement in `{}` and place the `or` keyword
in between them.

[,typeql]
----
match
  $p isa person, has full-name $n;
  { $n contains "Masako"; } or { $n contains "Kevin"; };
get $p;
----

The above query uses disjunctions to ensure one of two statements are matched:

. Finds all `person` entities that have a `full-name` attribute (`$n`).
. Checks to see if `$n` contains the text "`Masako`" *OR* if `$n` contains the text "`Kevin`":
 ** If either statement is true, there is a match.
 ** If neither statement is true, there is NO match.

The `person` entities are limited to those that have a `full-name` attribute whose value contains `Masako` or `Kevin`.

[#_complex_example]
==== Complex example

To better illustrate the possibilities, we will now look at an example of a more complex pattern.

image::example-pattern.png[Complex example]

The pattern is a conjunction of five different pattern types:

. *Conjunction 1* specifies the variables for two `person` instances, their `full-names`, `action`, and `file` that
has path `README.md`, specifies their types.
. *Disjunction* specifies that the actions of interest are either `modify_file` or `view_file`.
. *Negation 1* specifies that person `$p1` shall not have `full-name` with value of `Masako Holley`.
. *Negation 2* specifies that person `$p2` shall not have `full-name` with value of `Masako Holley`.
. *Conjunction 2* defines the pattern requiring the `file` to have `access` with `action` that we specified earlier,
and both instances of `person` to have a `permission` to the specified `access`.

In short, the above example finds pairs of people who both have permission to access the same file
with a path of `README.md`. The pattern additionally specifies both of them to not have name `Masako Holley` and
the access to be either `modify_file` or `view_file`.

== Query examples

=== How to execute a query

The easiest way to send a query to a TypeDB server is to use xref:clients:ROOT:studio.adoc[TypeDB Studio].
It will not only manage a TypeDB database connection for us, but will also process the results.
See the xref:typedb:ROOT:quickstart.adoc[Quickstart guide] for instructions on how to do this.

Alternatively, we can use any other xref:clients:ROOT:clients.adoc[TypeDB Client] to handle server connection,
sessions, transactions, etc.

Among the list of Clients, there are TypeDB drivers for different programming languages. Sending a query in one of
those should be as easy as calling a function. But it might require additional effort to control the session and
transaction. For example, see how to send a query in some of the most popular programming languages:
xref:clients:ROOT:java/java-overview.adoc[Java],
xref:clients:ROOT:node-js/node-js-overview.adoc[Node.js],
xref:clients:ROOT:python/python-overview.adoc[Python].

=== Schema

Use the example below to send a *get* query to a database schema (querying for types).

*Get query*

Get all attributes owned by `user` type and any of its subtypes:

[,typeql]
----
match
  $u sub user, owns $a;
get $a;
----

*Insert query* -- Use xref:schema.adoc#_define_schema[define] instead.

*Delete query* -- Use xref:schema.adoc#_undefine_a_type[undefine] instead.

*Update* -- Use xref:schema.adoc#_define_schema[define] and xref:schema.adoc#_undefine_a_type[undefine]
 instead.

=== Data

Use the examples below to try different types of queries to a database's data (querying for data instances).

==== Get query

To read data from a database use get query.

[,typeql]
----
match
  $u isa user, has credential $cr;
get $cr;
----

The above example matches all instances of the `user` type and all its subtypes that have `credential` attribute.
The get clause filters the result so only the `credential` attributes will be returned.

For more information on how to read data please see the xref:read.adoc[Reading data] page.

==== Insert query

To write new data to a database use the insert query.

[,typeql]
----
match
  $p isa person, has full-name "Bob";
insert
  $p has email "bob@vaticle.com";
----

The above example matches all instances of the `person` type and all its subtypes that have a `full-name` attribute
with the value of `Bob`. Then it inserts the data that all matched instances of `person` have ownership over the `email`
attribute type instance with the value of `bob@vaticle.com`.

For more information on how to write data please see the xref:write.adoc#_insert_query[Writing data] page.

==== Delete query

To delete data from a database use the delete query.

[,typeql]
----
match
  $p isa person, has email "bob@vaticle.com";
delete
  $p isa person;
----

The above example matches all instances of the `person` type and all its subtypes that have an `email` attribute
with the value of `bob@vaticle.com`. Then it deletes the matched instances of `person`.

For more information on how to delete data please see the xref:write.adoc#_delete_query[Writing data] page.

==== Update

To update data in a database we use a combined `match-delete-insert` query.

[,typeql]
----
match
  $p isa person, has full-name "Masako Holley", has email $email;
delete
  $p has $email;
insert
  $p has email "m.holley@vaticle.com";
----

The above example matches all instances of the `person` type and all its subtypes that have a `full-name` attribute
with the value of `Masako Holley` and have an `email` attribute (assigning the `$email` variable). It proceeds with
deleting the ownership of any `email` attributes that the matched `person` instances have. Finally, it inserts the
data that all matched instances of `person` have ownership over the `email` attribute with the value
of `m.holley@vaticle.com`.

[NOTE]
====
The `$email` variable can only have one concept for every matched pattern (solution for the `match` clause). So if
there will be more than one e-mail matched, then the result of match clause will contain multiple solutions.

Both delete clause and insert clause will be executed once for every matched pattern. But the insertion of ownership of
`email` attribute with the same value twice will not produce any duplication. Because any attribute instance can be
owned only once. Hence, all previously existent "email" attributes will be deleted and only one inserted.
====

For more information on how to update data see the xref:write.adoc#_update[Writing data] page.

For more information on how pattern matching produces multiple results see the Patterns overview
<<#_solutions,solutions>> description at the beginning of this page.

=== Complex query example

A `match` clause can only address data or types that already exist in a database.

The *declarative* nature of the TypeQL pattern means that if one of the `match` clause statements can't find any
instances in a database that might lead to finding no matches/solutions/answers to a query with that pattern.

For example:

[,typeql]
----
match
  $p isa person, has full-name $p-fname;
  $o isa object, has path $o-path;
  $a isa action, has name "view_file";
  $ac(object: $o, action: $a) isa access;
  $pe(subject: $p, access: $ac) isa permission;
  $p-fname = "Kevin Morrison";
----

The above query does the following:

. Finds all `person` entities (`$p`) that have `full-name` attribute with the value of `$p-fname` variable, that is
later set as string `Kevin Morrison`. There is actually only one such person in the *IAM database* by default.
. Finds all `object` entities (`$o`) that have `path` attribute (`$o-path`). The value of the attribute is not
limited but assigned a variable `$o-path`.
. Finds all `action` entities (`$a`) that have `name` attribute with the value of `view_file`. There is
actually only one such action in the *IAM database* by default.
. Finds all `access` relations (`$ac`) that relate `$o` (as `object` role) to `$a` (as `action` role).
. Finds all `permission` relations (`$pe`) that relate `$p` (as `subject` role) to `$ac` (as `access` role).
. States that `$p-fname` variable equals by value to a string `Kevin Morrison`.

This `match` clause can be a part of any query. For example, by appending a `delete $pe isa permission` statement
we can create a delete query that deletes all access to action `view_file` on all objects with any path attribute
owned for a person `Kevin Morrison`.

If we change the value of the `$p-fname` variable to something nonexistent in our database then the
`match` clause will return no results. Appending the same `delete` statement to such `match` clause would create a
useless query that can't delete anything because it can't find any data to delete.

[NOTE]
====
By default, without any other keywords added after a `match` clause, it performs as a get query and returns all
variables, mentioned in the `match` clause.
====
